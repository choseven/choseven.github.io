<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Selection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #instructions {
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }

        #fullscreenBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #000;
            color: #fff;
            border: 3px solid #fff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s;
        }

        #fullscreenBtn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
        }

        #fullscreenBtn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <button id="fullscreenBtn">* FULLSCREEN</button>
    <div id="instructions">Arrow Keys or WASD to move â€¢ Z or Enter to select</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Disable image smoothing for crisp pixels
        ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        // Internal game resolution (Undertale-style)
        const GAME_WIDTH = 640;
        const GAME_HEIGHT = 480;

        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // Scale canvas to fit screen while maintaining aspect ratio
        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Calculate scale to fit screen while maintaining 640x480 aspect ratio
            const scaleX = windowWidth / GAME_WIDTH;
            const scaleY = windowHeight / GAME_HEIGHT;
            const scale = Math.min(scaleX, scaleY);
            
            // Apply integer scaling for crisp pixels
            const finalScale = Math.max(1, Math.floor(scale));
            
            canvas.style.width = (GAME_WIDTH * finalScale) + 'px';
            canvas.style.height = (GAME_HEIGHT * finalScale) + 'px';
        }

        // Initial resize and setup listener
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Fullscreen functionality
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
                fullscreenBtn.textContent = '* EXIT FULLSCREEN';
            } else {
                document.exitFullscreen();
                fullscreenBtn.textContent = '* FULLSCREEN';
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenBtn.textContent = '* FULLSCREEN';
            }
        });

        // Frisk sprite configuration
        const CELL_WIDTH = 23;
        const CELL_HEIGHT = 33;
        const SPRITE_OFFSET_X = 3;
        const SPRITE_OFFSET_Y = 3;
        const SPRITE_WIDTH = 20;
        const SPRITE_HEIGHT = 30;
        const DISPLAY_SCALE = 2;

        // Movement and animation constants (GameMaker accurate)
        const TARGET_FPS = 30;
        const MOVE_SPEED = 4; // Double speed - Undertale uses ~4 pixels per frame
        const ANIMATION_SPEED = 6; // 8 / 1.333 - faster animation timing

        // Direction constants
        const DIRECTION_DOWN = 0;
        const DIRECTION_RIGHT = 1;
        const DIRECTION_UP = 2;
        const DIRECTION_LEFT = 3;

        const SPRITE_ROWS = {
            [DIRECTION_DOWN]: 0,
            [DIRECTION_RIGHT]: 1,
            [DIRECTION_UP]: 2,
            [DIRECTION_LEFT]: 1
        };

        const WALK_FRAMES_4 = [0, 1, 2, 3];
        const WALK_FRAMES_2 = [0, 1, 0, 1];
        const STAND_FRAME = 0;

        // Room definitions with actual games
        const rooms = {
            center: {
                name: 'ALL GAMES',
                bgColor: '#1a0a2e',
                floorColor: '#2d1b4e',
                exits: {
                    left: 'indie',
                    right: 'pokemon',
                    down: 'classic'
                },
                games: []
            },
            indie: {
                name: 'INDIE',
                bgColor: '#0a0a1a',
                floorColor: '#1b1b2d',
                exits: {
                    right: 'center'
                },
                games: [
                    { name: 'Undertale', url: 'https://choseven.github.io/Undertale' },
                    { name: 'Deltarune', url: 'https://choseven.github.io/Deltarune' },
                    { name: 'Hollow Knight', url: 'https://choseven.github.io/HollowKnight' },
                    { name: 'Last Breath First', url: 'https://choseven.github.io/LastBreathFirst' },
                    { name: 'Last Breath Third', url: 'https://choseven.github.io/LastBreathThird' },
                    { name: 'Undertale Yellow', url: 'https://choseven.github.io/UndertaleYellow' },
                    { name: 'Great Time Trio', url: 'https://choseven.github.io/GreatTimeTrio' }
                ]
            },
            pokemon: {
                name: 'POKEMON',
                bgColor: '#0a1a0a',
                floorColor: '#1b2d1b',
                exits: {
                    left: 'center'
                },
                games: [
                    { name: 'Pokemon Emerald', url: 'https://choseven.github.io/PokemonEmerald' },
                    { name: 'Pokemon Fire Red', url: 'https://choseven.github.io/PokemonFireRed' },
                    { name: 'Pokemon Heart Gold', url: 'https://choseven.github.io/PokemonHeartGold' },
                    { name: 'Pokemon Leaf Green', url: 'https://choseven.github.io/PokemonLeafGreen' },
                    { name: 'Pokemon Platinum', url: 'https://choseven.github.io/PokemonPlatinum' },
                    { name: 'Pokemon Red', url: 'https://choseven.github.io/PokemonRed' },
                    { name: 'Pokemon Ruby', url: 'https://choseven.github.io/PokemonRuby' },
                    { name: 'Pokemon Sapphire', url: 'https://choseven.github.io/PokemonSapphire' },
                    { name: 'Pokemon Soul Silver', url: 'https://choseven.github.io/PokemonSoulSilver' }
                ]
            },
            classic: {
                name: 'CLASSIC',
                bgColor: '#1a1a0a',
                floorColor: '#2d2d1b',
                exits: {
                    up: 'center'
                },
                games: [
                    { name: "Baldi's Basics", url: 'https://choseven.github.io/BaldiBasics' },
                    { name: 'Super Mario 64', url: 'https://choseven.github.io/SuperMario64' },
                    { name: 'Block Blast', url: 'https://choseven.github.io/BlockBlast' },
                    { name: 'Snake', url: 'https://choseven.github.io/Snake' },
                    { name: 'Cookie Clicker', url: 'https://choseven.github.io/CookieClicker' }
                ]
            }
        };

        // Game state
        let currentRoom = 'center';
        let frisk = {
            x: GAME_WIDTH / 2,
            y: GAME_HEIGHT / 2,
            direction: DIRECTION_DOWN,
            frame: 0,
            animTimer: 0,
            isMoving: false
        };

        let selectedGame = 0;
        let inMenu = false;
        let transitioning = false;
        let transitionAlpha = 0;
        let transitionTarget = null;
        let transitionDirection = null;
        let friskDanceToggle = false; // For alternating dance direction

        let lastTime = 0;
        let accumulator = 0;
        const FRAME_TIME = 1000 / TARGET_FPS;

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
            
            if (inMenu) {
                const room = rooms[currentRoom];
                if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                    selectedGame = Math.max(0, selectedGame - 1);
                    playSound('select');
                } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                    selectedGame = Math.min(room.games.length - 1, selectedGame + 1);
                    playSound('select');
                } else if (e.code === 'KeyZ' || e.code === 'Enter') {
                    playSound('confirm');
                    const selectedGameData = room.games[selectedGame];
                    
                    // Navigate to the game URL
                    window.location.href = selectedGameData.url;
                } else if (e.code === 'KeyX' || e.code === 'Escape') {
                    inMenu = false;
                    playSound('cancel');
                }
            } else {
                if (e.code === 'KeyZ' || e.code === 'Enter') {
                    const room = rooms[currentRoom];
                    if (room.games.length > 0) {
                        const centerX = GAME_WIDTH / 2;
                        const centerY = GAME_HEIGHT / 2 - 50;
                        const dist = Math.hypot(frisk.x - centerX, frisk.y - centerY);
                        if (dist < 60) {
                            inMenu = true;
                            selectedGame = 0;
                            playSound('confirm');
                        }
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Load spritesheet
        const spritesheet = new Image();
        spritesheet.src = 'frisk.png';

        // Simple sound effects
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            if (type === 'select') {
                osc.frequency.value = 400;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.05);
            } else if (type === 'confirm') {
                osc.frequency.value = 600;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'cancel') {
                osc.frequency.value = 200;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        function getSpriteCoords(direction, frameIndex, isMoving) {
            const row = SPRITE_ROWS[direction];
            
            let col;
            if (!isMoving) {
                col = STAND_FRAME;
            } else {
                if (direction === DIRECTION_UP || direction === DIRECTION_DOWN) {
                    col = WALK_FRAMES_4[frameIndex % 4];
                } else {
                    col = WALK_FRAMES_2[frameIndex % 4];
                }
            }
            
            const sx = SPRITE_OFFSET_X + col * CELL_WIDTH;
            const sy = SPRITE_OFFSET_Y + row * CELL_HEIGHT;
            
            return { 
                sx, 
                sy, 
                flip: direction === DIRECTION_RIGHT
            };
        }

        function drawFrisk() {
            const { sx, sy, flip } = getSpriteCoords(frisk.direction, frisk.frame, frisk.isMoving);
            
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            const drawWidth = SPRITE_WIDTH * DISPLAY_SCALE;
            const drawHeight = SPRITE_HEIGHT * DISPLAY_SCALE;
            const drawX = Math.floor(frisk.x - drawWidth / 2);
            const drawY = Math.floor(frisk.y - drawHeight / 2);
            
            if (flip) {
                ctx.translate(drawX + drawWidth, drawY);
                ctx.scale(-1, 1);
                ctx.drawImage(
                    spritesheet,
                    sx, sy, SPRITE_WIDTH, SPRITE_HEIGHT,
                    0, 0,
                    drawWidth, drawHeight
                );
            } else {
                ctx.drawImage(
                    spritesheet,
                    sx, sy, SPRITE_WIDTH, SPRITE_HEIGHT,
                    drawX, drawY,
                    drawWidth, drawHeight
                );
            }
            
            ctx.restore();
        }

        function drawRoom() {
            const room = rooms[currentRoom];
            
            ctx.fillStyle = room.bgColor;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.fillStyle = room.floorColor;
            const tileSize = 32;
            for (let y = 100; y < GAME_HEIGHT - 50; y += tileSize) {
                for (let x = 50; x < GAME_WIDTH - 50; x += tileSize) {
                    if ((Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2 === 0) {
                        ctx.fillRect(x, y, tileSize, tileSize);
                    }
                }
            }
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.strokeRect(50, 100, GAME_WIDTH - 100, GAME_HEIGHT - 150);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(room.name, GAME_WIDTH / 2, 60);
            
            ctx.font = '14px "Courier New", monospace';
            
            if (room.exits.left) {
                ctx.fillStyle = '#4a4';
                ctx.fillRect(50, GAME_HEIGHT / 2 - 30, 10, 60);
                ctx.fillStyle = '#fff';
                ctx.save();
                ctx.translate(30, GAME_HEIGHT / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(rooms[room.exits.left].name, 0, 0);
                ctx.restore();
            }
            
            if (room.exits.right) {
                ctx.fillStyle = '#4a4';
                ctx.fillRect(GAME_WIDTH - 60, GAME_HEIGHT / 2 - 30, 10, 60);
                ctx.fillStyle = '#fff';
                ctx.save();
                ctx.translate(GAME_WIDTH - 20, GAME_HEIGHT / 2);
                ctx.rotate(Math.PI / 2);
                ctx.fillText(rooms[room.exits.right].name, 0, 0);
                ctx.restore();
            }
            
            if (room.exits.up) {
                ctx.fillStyle = '#4a4';
                ctx.fillRect(GAME_WIDTH / 2 - 30, 100, 60, 10);
                ctx.fillStyle = '#fff';
                ctx.fillText(rooms[room.exits.up].name, GAME_WIDTH / 2, 85);
            }
            
            if (room.exits.down) {
                ctx.fillStyle = '#4a4';
                ctx.fillRect(GAME_WIDTH / 2 - 30, GAME_HEIGHT - 60, 60, 10);
                ctx.fillStyle = '#fff';
                ctx.fillText(rooms[room.exits.down].name, GAME_WIDTH / 2, GAME_HEIGHT - 30);
            }
            
            if (room.games.length > 0) {
                const saveX = GAME_WIDTH / 2;
                const saveY = GAME_HEIGHT / 2 - 50;
                
                const glow = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, 255, 0, ${glow})`;
                ctx.beginPath();
                ctx.arc(saveX, saveY, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px "Courier New", monospace';
                ctx.fillText('Press Z to browse games', saveX, saveY + 40);
            }
            
            if (currentRoom === 'center') {
                ctx.fillStyle = '#fff';
                ctx.font = '16px "Courier New", monospace';
                ctx.fillText('Welcome to the Game Hub!', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50);
                ctx.font = '12px "Courier New", monospace';
                ctx.fillText('Walk to an exit to explore game categories', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);
            }
        }

        function drawMenu() {
            const room = rooms[currentRoom];
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            const menuWidth = 400;
            const menuHeight = 300;
            const menuX = (GAME_WIDTH - menuWidth) / 2;
            const menuY = (GAME_HEIGHT - menuHeight) / 2;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.strokeRect(menuX, menuY, menuWidth, menuHeight);
            
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 20px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(room.name, GAME_WIDTH / 2, menuY + 40);
            
            ctx.font = '16px "Courier New", monospace';
            ctx.textAlign = 'left';
            
            room.games.forEach((game, i) => {
                const y = menuY + 80 + i * 40;
                
                if (i === selectedGame) {
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.moveTo(menuX + 40, y - 5);
                    ctx.lineTo(menuX + 50, y + 5);
                    ctx.lineTo(menuX + 40, y + 15);
                    ctx.lineTo(menuX + 30, y + 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ff0';
                } else {
                    ctx.fillStyle = '#fff';
                }
                
                ctx.fillText(game, menuX + 70, y + 10);
            });
            
            ctx.fillStyle = '#888';
            ctx.font = '12px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Z - Select    X - Back', GAME_WIDTH / 2, menuY + menuHeight - 20);
        }

        function drawTransition() {
            ctx.fillStyle = `rgba(0, 0, 0, ${transitionAlpha})`;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        }

        function update() {
            if (transitioning) {
                transitionAlpha += 0.05;
                if (transitionAlpha >= 1 && transitionTarget) {
                    currentRoom = transitionTarget;
                    
                    if (transitionDirection === DIRECTION_DOWN) {
                        frisk.y = 150;
                        frisk.x = GAME_WIDTH / 2;
                    } else if (transitionDirection === DIRECTION_UP) {
                        frisk.y = GAME_HEIGHT - 100;
                        frisk.x = GAME_WIDTH / 2;
                    } else if (transitionDirection === DIRECTION_RIGHT) {
                        frisk.x = 100;
                        frisk.y = GAME_HEIGHT / 2;
                    } else if (transitionDirection === DIRECTION_LEFT) {
                        frisk.x = GAME_WIDTH - 100;
                        frisk.y = GAME_HEIGHT / 2;
                    }
                    
                    transitionTarget = null;
                }
                if (!transitionTarget && transitionAlpha > 0) {
                    transitionAlpha -= 0.05;
                    if (transitionAlpha <= 0) {
                        transitionAlpha = 0;
                        transitioning = false;
                    }
                }
                return;
            }
            
            if (inMenu) return;
            
            let dx = 0;
            let dy = 0;
            let bothVertical = false;
            
            // Horizontal movement - Right takes priority
            if (keys['ArrowRight'] || keys['KeyD']) {
                dx = MOVE_SPEED;
                frisk.direction = DIRECTION_RIGHT;
            } else if (keys['ArrowLeft'] || keys['KeyA']) {
                dx = -MOVE_SPEED;
                frisk.direction = DIRECTION_LEFT;
            }
            
            // Vertical movement - Up takes priority (enables Frisk dance)
            if ((keys['ArrowUp'] || keys['KeyW']) && (keys['ArrowDown'] || keys['KeyS'])) {
                // Both keys pressed - this enables the dance
                bothVertical = true;
                dy = -MOVE_SPEED;
                frisk.direction = DIRECTION_UP;
            } else if (keys['ArrowUp'] || keys['KeyW']) {
                dy = -MOVE_SPEED;
                frisk.direction = DIRECTION_UP;
            } else if (keys['ArrowDown'] || keys['KeyS']) {
                dy = MOVE_SPEED;
                frisk.direction = DIRECTION_DOWN;
            }
            
            if (dx !== 0 && dy !== 0) {
                const diag = MOVE_SPEED / Math.sqrt(2);
                dx = dx > 0 ? diag : -diag;
                dy = dy > 0 ? diag : -diag;
            }
            
            frisk.isMoving = dx !== 0 || dy !== 0;
            
            const newX = frisk.x + dx;
            const newY = frisk.y + dy;
            
            const room = rooms[currentRoom];
            let hitExit = null;
            
            if (newX < 70) {
                if (room.exits.left && newY > GAME_HEIGHT / 2 - 40 && newY < GAME_HEIGHT / 2 + 40) {
                    hitExit = room.exits.left;
                    transitionDirection = DIRECTION_LEFT;
                } else {
                    frisk.x = Math.max(70, newX);
                }
            } else if (newX > GAME_WIDTH - 70) {
                if (room.exits.right && newY > GAME_HEIGHT / 2 - 40 && newY < GAME_HEIGHT / 2 + 40) {
                    hitExit = room.exits.right;
                    transitionDirection = DIRECTION_RIGHT;
                } else {
                    frisk.x = Math.min(GAME_WIDTH - 70, newX);
                }
            } else {
                frisk.x = newX;
            }
            
            if (newY < 120) {
                if (room.exits.up && newX > GAME_WIDTH / 2 - 40 && newX < GAME_WIDTH / 2 + 40) {
                    hitExit = room.exits.up;
                    transitionDirection = DIRECTION_UP;
                } else {
                    frisk.y = Math.max(120, newY);
                    // Frisk dance: if both vertical keys pressed and hit top wall, alternate direction each frame
                    if (bothVertical && dy < 0) {
                        friskDanceToggle = !friskDanceToggle;
                        frisk.direction = friskDanceToggle ? DIRECTION_UP : DIRECTION_DOWN;
                    }
                }
            } else if (newY > GAME_HEIGHT - 80) {
                if (room.exits.down && newX > GAME_WIDTH / 2 - 40 && newX < GAME_WIDTH / 2 + 40) {
                    hitExit = room.exits.down;
                    transitionDirection = DIRECTION_DOWN;
                } else {
                    frisk.y = Math.min(GAME_HEIGHT - 80, newY);
                }
            } else {
                frisk.y = newY;
            }
            
            if (hitExit) {
                transitioning = true;
                transitionTarget = hitExit;
                transitionAlpha = 0;
            }
            
            if (frisk.isMoving) {
                frisk.animTimer++;
                if (frisk.animTimer >= ANIMATION_SPEED) {
                    frisk.animTimer = 0;
                    frisk.frame = (frisk.frame + 1) % 4;
                }
            } else {
                frisk.frame = 0;
                frisk.animTimer = 0;
            }
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            drawRoom();
            drawFrisk();
            
            if (inMenu) {
                drawMenu();
            }
            
            if (transitioning || transitionAlpha > 0) {
                drawTransition();
            }
        }

        function gameLoop(currentTime) {
            if (lastTime === 0) {
                lastTime = currentTime;
            }
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            accumulator += deltaTime;
            
            while (accumulator >= FRAME_TIME) {
                update();
                accumulator -= FRAME_TIME;
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        spritesheet.onload = () => {
            console.log('Spritesheet loaded!');
            requestAnimationFrame(gameLoop);
        };

        spritesheet.onerror = () => {
            console.error('Failed to load spritesheet');
            requestAnimationFrame(gameLoop);
        };

        document.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        });
        document.addEventListener('keydown', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }, { once: true });
    </script>
</body>
</html>