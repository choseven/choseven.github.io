<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Menu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #instructions {
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }

        #fullscreenBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #000;
            color: #fff;
            border: 3px solid #fff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s;
        }

        #fullscreenBtn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
        }

        #fullscreenBtn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <button id="fullscreenBtn">* FULLSCREEN</button>
    <div id="instructions">Arrow Keys or WASD to move • Space to select • 1-4 to switch tabs</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Disable image smoothing for crisp pixels
        ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        // Internal game resolution
        const GAME_WIDTH = 640;
        const GAME_HEIGHT = 480;

        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // Scale canvas to fit screen
        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            const scaleX = windowWidth / GAME_WIDTH;
            const scaleY = windowHeight / GAME_HEIGHT;
            const scale = Math.min(scaleX, scaleY);
            
            const finalScale = Math.max(1, Math.floor(scale));
            
            canvas.style.width = (GAME_WIDTH * finalScale) + 'px';
            canvas.style.height = (GAME_HEIGHT * finalScale) + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Fullscreen functionality
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
                fullscreenBtn.textContent = '* EXIT FULLSCREEN';
            } else {
                document.exitFullscreen();
                fullscreenBtn.textContent = '* FULLSCREEN';
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenBtn.textContent = '* FULLSCREEN';
            }
        });

        // Frisk sprite configuration
        const CELL_WIDTH = 23;
        const CELL_HEIGHT = 33;
        const SPRITE_OFFSET_X = 3;
        const SPRITE_OFFSET_Y = 3;
        const SPRITE_WIDTH = 20;
        const SPRITE_HEIGHT = 30;
        const DISPLAY_SCALE = 2;

        // Movement and animation constants
        const TARGET_FPS = 30;
        const MOVE_SPEED = 4;
        const ANIMATION_SPEED = 6;

        // Direction constants
        const DIRECTION_DOWN = 0;
        const DIRECTION_RIGHT = 1;
        const DIRECTION_UP = 2;
        const DIRECTION_LEFT = 3;

        const SPRITE_ROWS = {
            [DIRECTION_DOWN]: 0,
            [DIRECTION_RIGHT]: 1,
            [DIRECTION_UP]: 2,
            [DIRECTION_LEFT]: 1
        };

        const WALK_FRAMES_4 = [0, 1, 2, 3];
        const WALK_FRAMES_2 = [0, 1, 0, 1];
        const STAND_FRAME = 0;

        // Game database with categories
        const allGames = [
            { name: 'Undertale', url: 'https://choseven.github.io/Undertale', category: 'indie' },
            { name: 'Deltarune', url: 'https://choseven.github.io/Deltarune', category: 'indie' },
            { name: 'Block Blast', url: 'https://choseven.github.io/BlockBlast', category: 'classic' },
            { name: 'Hollow Knight', url: 'https://choseven.github.io/HollowKnight', category: 'indie' },
            { name: 'Last Breath Third', url: 'https://choseven.github.io/LastBreathThird', category: 'indie' },
            { name: 'Last Breath First', url: 'https://choseven.github.io/LastBreathFirst', category: 'indie' },
            { name: 'Pokemon Emerald', url: 'https://choseven.github.io/PokemonEmerald', category: 'pokemon' },
            { name: 'Pokemon Fire Red', url: 'https://choseven.github.io/PokemonFireRed', category: 'pokemon' },
            { name: 'Pokemon Heart Gold', url: 'https://choseven.github.io/PokemonHeartGold', category: 'pokemon' },
            { name: 'Pokemon Leaf Green', url: 'https://choseven.github.io/PokemonLeafGreen', category: 'pokemon' },
            { name: 'Pokemon Platinum', url: 'https://choseven.github.io/PokemonPlatinum', category: 'pokemon' },
            { name: 'Pokemon Red', url: 'https://choseven.github.io/PokemonRed', category: 'pokemon' },
            { name: 'Pokemon Ruby', url: 'https://choseven.github.io/PokemonRuby', category: 'pokemon' },
            { name: 'Pokemon Sapphire', url: 'https://choseven.github.io/PokemonSapphire', category: 'pokemon' },
            { name: 'Pokemon Soul Silver', url: 'https://choseven.github.io/PokemonSoulSilver', category: 'pokemon' },
            { name: 'Snake', url: 'https://choseven.github.io/Snake', category: 'classic' },
            { name: 'Undertale Yellow', url: 'https://choseven.github.io/UndertaleYellow', category: 'indie' },
            { name: 'Great Time Trio', url: 'https://choseven.github.io/GreatTimeTrio', category: 'indie' },
            { name: 'Cookie Clicker', url: 'https://choseven.github.io/CookieClicker', category: 'classic' },
            { name: 'Super Mario 64', url: 'https://choseven.github.io/SuperMario64', category: 'classic' },
            { name: "Baldi's Basics", url: 'https://choseven.github.io/BaldiBasics', category: 'classic' }
        ];

        let currentTab = 'all';
        let buttonTextureWidth = 0;
        let buttonTextureHeight = 0;
        const BUTTON_WIDTH = 180; // Fixed width for all buttons
        const BUTTON_HEIGHT = 50;  // Fixed height for all buttons
        const BUTTON_SPACING_X = 20;
        const BUTTON_SPACING_Y = 15;
        const COLUMNS = 3;
        const BASE_FONT_SIZE = 13; // Consistent font size for all text
        let cameraY = 0;
        const SCROLL_SPEED = 4;

        // Game state
        let frisk = {
            x: GAME_WIDTH / 2,
            y: 80,
            direction: DIRECTION_DOWN,
            frame: 0,
            animTimer: 0,
            isMoving: false
        };

        let lastTime = 0;
        let accumulator = 0;
        const FRAME_TIME = 1000 / TARGET_FPS;

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
            
            // Tab switching with 1-4 keys
            if (e.code === 'Digit1') {
                currentTab = 'all';
                cameraY = 0;
                playSound('select');
            } else if (e.code === 'Digit2') {
                currentTab = 'indie';
                cameraY = 0;
                playSound('select');
            } else if (e.code === 'Digit3') {
                currentTab = 'pokemon';
                cameraY = 0;
                playSound('select');
            } else if (e.code === 'Digit4') {
                currentTab = 'classic';
                cameraY = 0;
                playSound('select');
            }
            
            // Check if space is pressed and Frisk is over a button
            if (e.code === 'Space') {
                const hoveredGame = getHoveredGame();
                if (hoveredGame) {
                    playSound('confirm');
                    // Navigate to the game URL
                    setTimeout(() => {
                        window.location.href = hoveredGame.url;
                    }, 100);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Load images
        const spritesheet = new Image();
        spritesheet.src = 'frisk.png';

        const buttonTexture = new Image();
        buttonTexture.src = 'button1.png';

        // Simple sound effects
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            if (type === 'select') {
                osc.frequency.value = 400;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.05);
            } else if (type === 'confirm') {
                osc.frequency.value = 600;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        function getSpriteCoords(direction, frameIndex, isMoving) {
            const row = SPRITE_ROWS[direction];
            
            let col;
            if (!isMoving) {
                col = STAND_FRAME;
            } else {
                if (direction === DIRECTION_UP || direction === DIRECTION_DOWN) {
                    col = WALK_FRAMES_4[frameIndex % 4];
                } else {
                    col = WALK_FRAMES_2[frameIndex % 4];
                }
            }
            
            const sx = SPRITE_OFFSET_X + col * CELL_WIDTH;
            const sy = SPRITE_OFFSET_Y + row * CELL_HEIGHT;
            
            return { 
                sx, 
                sy, 
                flip: direction === DIRECTION_RIGHT
            };
        }

        function getCurrentGames() {
            if (currentTab === 'all') {
                return allGames;
            }
            return allGames.filter(game => game.category === currentTab);
        }

        function calculateGamePositions() {
            const games = getCurrentGames();
            const gridStartY = 180; // Moved down to avoid clipping with header
            const positions = [];
            
            // Calculate grid layout with fixed button sizes
            const rows = Math.ceil(games.length / COLUMNS);
            const totalGridWidth = COLUMNS * BUTTON_WIDTH + (COLUMNS - 1) * BUTTON_SPACING_X;
            const startX = (GAME_WIDTH - totalGridWidth) / 2 + BUTTON_WIDTH / 2;
            
            games.forEach((game, index) => {
                const col = index % COLUMNS;
                const row = Math.floor(index / COLUMNS);
                
                const x = startX + col * (BUTTON_WIDTH + BUTTON_SPACING_X);
                const y = gridStartY + row * (BUTTON_HEIGHT + BUTTON_SPACING_Y) - cameraY;
                
                positions.push({
                    ...game,
                    x: x,
                    y: y,
                    width: BUTTON_WIDTH,
                    height: BUTTON_HEIGHT
                });
            });
            
            return positions;
        }

        function getMaxCameraY() {
            const games = getCurrentGames();
            const rows = Math.ceil(games.length / COLUMNS);
            const totalHeight = rows * (BUTTON_HEIGHT + BUTTON_SPACING_Y);
            const viewableHeight = GAME_HEIGHT - 200;
            return Math.max(0, totalHeight - viewableHeight);
        }

        function drawFrisk() {
            const { sx, sy, flip } = getSpriteCoords(frisk.direction, frisk.frame, frisk.isMoving);
            
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            const drawWidth = SPRITE_WIDTH * DISPLAY_SCALE;
            const drawHeight = SPRITE_HEIGHT * DISPLAY_SCALE;
            const drawX = Math.floor(frisk.x - drawWidth / 2);
            const drawY = Math.floor(frisk.y - drawHeight / 2);
            
            if (flip) {
                ctx.translate(drawX + drawWidth, drawY);
                ctx.scale(-1, 1);
                ctx.drawImage(
                    spritesheet,
                    sx, sy, SPRITE_WIDTH, SPRITE_HEIGHT,
                    0, 0,
                    drawWidth, drawHeight
                );
            } else {
                ctx.drawImage(
                    spritesheet,
                    sx, sy, SPRITE_WIDTH, SPRITE_HEIGHT,
                    drawX, drawY,
                    drawWidth, drawHeight
                );
            }
            
            ctx.restore();
        }

        function getHoveredGame() {
            const games = calculateGamePositions();
            for (let game of games) {
                const left = game.x - game.width / 2;
                const right = game.x + game.width / 2;
                const top = game.y - game.height / 2;
                const bottom = game.y + game.height / 2;
                
                if (frisk.x >= left && frisk.x <= right && frisk.y >= top && frisk.y <= bottom) {
                    return game;
                }
            }
            return null;
        }

        function drawButtons() {
            const games = calculateGamePositions();
            const hoveredGame = getHoveredGame();
            
            games.forEach(game => {
                // Skip buttons that are off-screen
                if (game.y + game.height < 140 || game.y > GAME_HEIGHT - 20) {
                    return;
                }
                
                const isHovered = game === hoveredGame;
                
                ctx.save();
                
                const left = game.x - game.width / 2;
                const top = game.y - game.height / 2;
                
                ctx.imageSmoothingEnabled = false;
                
                if (buttonTexture.complete && buttonTextureWidth > 0) {
                    // Use 9-slice technique to tile the button without stretching
                    const edgeSize = Math.min(16, Math.floor(buttonTextureWidth / 3), Math.floor(buttonTextureHeight / 3));
                    
                    // Draw corners (never stretched)
                    // Top-left
                    ctx.drawImage(buttonTexture, 0, 0, edgeSize, edgeSize, 
                                  left, top, edgeSize, edgeSize);
                    // Top-right
                    ctx.drawImage(buttonTexture, buttonTextureWidth - edgeSize, 0, edgeSize, edgeSize,
                                  left + BUTTON_WIDTH - edgeSize, top, edgeSize, edgeSize);
                    // Bottom-left
                    ctx.drawImage(buttonTexture, 0, buttonTextureHeight - edgeSize, edgeSize, edgeSize,
                                  left, top + BUTTON_HEIGHT - edgeSize, edgeSize, edgeSize);
                    // Bottom-right
                    ctx.drawImage(buttonTexture, buttonTextureWidth - edgeSize, buttonTextureHeight - edgeSize, edgeSize, edgeSize,
                                  left + BUTTON_WIDTH - edgeSize, top + BUTTON_HEIGHT - edgeSize, edgeSize, edgeSize);
                    
                    // Draw edges (tiled, not stretched)
                    const centerWidth = buttonTextureWidth - (edgeSize * 2);
                    const centerHeight = buttonTextureHeight - (edgeSize * 2);
                    
                    // Top edge
                    for (let x = edgeSize; x < BUTTON_WIDTH - edgeSize; x += centerWidth) {
                        const w = Math.min(centerWidth, BUTTON_WIDTH - edgeSize - x);
                        ctx.drawImage(buttonTexture, edgeSize, 0, w, edgeSize,
                                      left + x, top, w, edgeSize);
                    }
                    // Bottom edge
                    for (let x = edgeSize; x < BUTTON_WIDTH - edgeSize; x += centerWidth) {
                        const w = Math.min(centerWidth, BUTTON_WIDTH - edgeSize - x);
                        ctx.drawImage(buttonTexture, edgeSize, buttonTextureHeight - edgeSize, w, edgeSize,
                                      left + x, top + BUTTON_HEIGHT - edgeSize, w, edgeSize);
                    }
                    // Left edge
                    for (let y = edgeSize; y < BUTTON_HEIGHT - edgeSize; y += centerHeight) {
                        const h = Math.min(centerHeight, BUTTON_HEIGHT - edgeSize - y);
                        ctx.drawImage(buttonTexture, 0, edgeSize, edgeSize, h,
                                      left, top + y, edgeSize, h);
                    }
                    // Right edge
                    for (let y = edgeSize; y < BUTTON_HEIGHT - edgeSize; y += centerHeight) {
                        const h = Math.min(centerHeight, BUTTON_HEIGHT - edgeSize - y);
                        ctx.drawImage(buttonTexture, buttonTextureWidth - edgeSize, edgeSize, edgeSize, h,
                                      left + BUTTON_WIDTH - edgeSize, top + y, edgeSize, h);
                    }
                    
                    // Draw center (tiled)
                    for (let y = edgeSize; y < BUTTON_HEIGHT - edgeSize; y += centerHeight) {
                        for (let x = edgeSize; x < BUTTON_WIDTH - edgeSize; x += centerWidth) {
                            const w = Math.min(centerWidth, BUTTON_WIDTH - edgeSize - x);
                            const h = Math.min(centerHeight, BUTTON_HEIGHT - edgeSize - y);
                            ctx.drawImage(buttonTexture, edgeSize, edgeSize, w, h,
                                          left + x, top + y, w, h);
                        }
                    }
                } else {
                    // Fallback if texture not loaded
                    ctx.fillStyle = '#222';
                    ctx.fillRect(left, top, game.width, game.height);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(left, top, game.width, game.height);
                }
                
                // Highlight if hovered
                if (isHovered) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fillRect(left, top, game.width, game.height);
                    
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(left, top, game.width, game.height);
                }
                
                // Draw text on button with consistent font size
                ctx.fillStyle = isHovered ? '#ff0' : '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${BASE_FONT_SIZE}px "Courier New", monospace`;
                
                const maxWidth = game.width - 30; // Leave padding
                const words = game.name.split(' ');
                
                // Check if we need to wrap text
                const fullTextWidth = ctx.measureText(game.name).width;
                
                if (fullTextWidth > maxWidth && words.length > 1) {
                    // Multi-line text - split intelligently
                    let line1 = '';
                    let line2 = '';
                    let currentLine = '';
                    
                    for (let i = 0; i < words.length; i++) {
                        const testLine = currentLine ? currentLine + ' ' + words[i] : words[i];
                        const testWidth = ctx.measureText(testLine).width;
                        
                        if (testWidth > maxWidth && currentLine) {
                            line1 = currentLine;
                            line2 = words.slice(i).join(' ');
                            break;
                        }
                        currentLine = testLine;
                    }
                    
                    if (!line1) {
                        line1 = currentLine;
                    }
                    
                    const lineHeight = BASE_FONT_SIZE + 2;
                    ctx.fillText(line1, game.x, game.y - lineHeight / 2);
                    if (line2) {
                        ctx.fillText(line2, game.x, game.y + lineHeight / 2);
                    }
                } else {
                    // Single line
                    ctx.fillText(game.name, game.x, game.y);
                }
                
                ctx.restore();
            });
        }

        function update() {
            let dx = 0;
            let dy = 0;
            
            // Horizontal movement
            if (keys['ArrowRight'] || keys['KeyD']) {
                dx = MOVE_SPEED;
                frisk.direction = DIRECTION_RIGHT;
            } else if (keys['ArrowLeft'] || keys['KeyA']) {
                dx = -MOVE_SPEED;
                frisk.direction = DIRECTION_LEFT;
            }
            
            // Vertical movement
            if (keys['ArrowUp'] || keys['KeyW']) {
                dy = -MOVE_SPEED;
                frisk.direction = DIRECTION_UP;
            } else if (keys['ArrowDown'] || keys['KeyS']) {
                dy = MOVE_SPEED;
                frisk.direction = DIRECTION_DOWN;
            }
            
            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                const diag = MOVE_SPEED / Math.sqrt(2);
                dx = dx > 0 ? diag : -diag;
                dy = dy > 0 ? diag : -diag;
            }
            
            frisk.isMoving = dx !== 0 || dy !== 0;
            
            // Update position with boundaries
            const newX = frisk.x + dx;
            const newY = frisk.y + dy;
            
            frisk.x = Math.max(30, Math.min(GAME_WIDTH - 30, newX));
            frisk.y = Math.max(140, Math.min(GAME_HEIGHT - 30, newY));
            
            // Camera follows Frisk vertically - scroll the view when Frisk gets near edges
            const maxCameraY = getMaxCameraY();
            if (maxCameraY > 0) {
                // Scroll down when Frisk gets to bottom third of screen
                if (frisk.y > GAME_HEIGHT - 150 && dy > 0) {
                    const newCameraY = cameraY + SCROLL_SPEED;
                    if (newCameraY <= maxCameraY) {
                        cameraY = newCameraY;
                        frisk.y -= SCROLL_SPEED; // Keep Frisk in same screen position
                    }
                }
                // Scroll up when Frisk gets to top third of screen
                else if (frisk.y < 200 && dy < 0) {
                    const newCameraY = cameraY - SCROLL_SPEED;
                    if (newCameraY >= 0) {
                        cameraY = newCameraY;
                        frisk.y += SCROLL_SPEED; // Keep Frisk in same screen position
                    }
                }
            }
            
            // Update animation
            if (frisk.isMoving) {
                frisk.animTimer++;
                if (frisk.animTimer >= ANIMATION_SPEED) {
                    frisk.animTimer = 0;
                    frisk.frame = (frisk.frame + 1) % 4;
                }
            } else {
                frisk.frame = 0;
                frisk.animTimer = 0;
            }
        }

        function drawTabs() {
            const tabs = [
                { id: 'all', name: 'ALL', x: GAME_WIDTH / 2 - 150 },
                { id: 'indie', name: 'INDIE', x: GAME_WIDTH / 2 - 50 },
                { id: 'pokemon', name: 'POKEMON', x: GAME_WIDTH / 2 + 50 },
                { id: 'classic', name: 'CLASSIC', x: GAME_WIDTH / 2 + 150 }
            ];
            
            tabs.forEach(tab => {
                const isActive = currentTab === tab.id;
                
                ctx.fillStyle = isActive ? '#fff' : '#666';
                ctx.font = isActive ? 'bold 14px "Courier New", monospace' : '14px "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(tab.name, tab.x, 100);
                
                // Underline active tab
                if (isActive) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const textWidth = ctx.measureText(tab.name).width;
                    ctx.moveTo(tab.x - textWidth / 2, 108);
                    ctx.lineTo(tab.x + textWidth / 2, 108);
                    ctx.stroke();
                }
            });
            
            // Tab instructions
            ctx.fillStyle = '#888';
            ctx.font = '10px "Courier New", monospace';
            ctx.fillText('Press 1-4 to switch tabs', GAME_WIDTH / 2, 120);
        }

        function render() {
            // Background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('GAME SELECT', GAME_WIDTH / 2, 40);
            
            // Draw tabs
            drawTabs();
            
            // Set clipping region to prevent buttons from overlapping header
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 140, GAME_WIDTH, GAME_HEIGHT - 140);
            ctx.clip();
            
            // Draw buttons (will be clipped)
            drawButtons();
            
            ctx.restore();
            
            // Draw Frisk (on top of everything)
            drawFrisk();
            
            // Draw instruction if over a button
            const hoveredGame = getHoveredGame();
            if (hoveredGame) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(GAME_WIDTH / 2 - 100, GAME_HEIGHT - 50, 200, 30);
                ctx.fillStyle = '#ff0';
                ctx.font = '14px "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Press SPACE to play!', GAME_WIDTH / 2, GAME_HEIGHT - 32);
            }
        }

        function gameLoop(currentTime) {
            if (lastTime === 0) {
                lastTime = currentTime;
            }
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            accumulator += deltaTime;
            
            while (accumulator >= FRAME_TIME) {
                update();
                accumulator -= FRAME_TIME;
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        // Start game when images load
        let spritesheetLoaded = false;
        let buttonTextureLoaded = false;

        function checkStart() {
            if (spritesheetLoaded && buttonTextureLoaded) {
                console.log('All assets loaded!');
                requestAnimationFrame(gameLoop);
            }
        }

        spritesheet.onload = () => {
            console.log('Spritesheet loaded!');
            spritesheetLoaded = true;
            checkStart();
        };

        buttonTexture.onload = () => {
            console.log('Button texture loaded!');
            buttonTextureWidth = buttonTexture.width;
            buttonTextureHeight = buttonTexture.height;
            console.log('Button dimensions:', buttonTextureWidth, 'x', buttonTextureHeight);
            buttonTextureLoaded = true;
            checkStart();
        };

        spritesheet.onerror = () => {
            console.error('Failed to load spritesheet');
            spritesheetLoaded = true;
            checkStart();
        };

        buttonTexture.onerror = () => {
            console.error('Failed to load button texture');
            buttonTextureLoaded = true;
            checkStart();
        };

        // Audio context unlock
        document.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        });
        document.addEventListener('keydown', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }, { once: true });
    </script>
</body>
</html>