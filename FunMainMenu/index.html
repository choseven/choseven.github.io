<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Menu</title>
    <style>
        @font-face {
            font-family: 'DeterminationMono';
            src: url('DeterminationMonoWebRegular.woff2') format('woff2'),
                 url('DTM-Mono.otf') format('opentype'),
                 url('DTM-Mono.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: block;
        }

        @font-face {
            font-family: 'Chara';
            src: url('chara.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: block;
        }

        @font-face {
            font-family: 'Windy';
            src: url('windy.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: block;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            /* Force sharper text rendering */
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            font-smooth: never;
            text-rendering: geometricPrecision;
        }

        #gameCanvas {
            display: block;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Additional sharpness hints */
            shape-rendering: crispEdges;
        }

        #instructions {
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: #fff;
            font-family: 'Windy', 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }

        #fullscreenBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #000;
            color: #fff;
            border: 3px solid #fff;
            font-family: 'Windy', 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s;
        }

        #fullscreenBtn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
        }

        #fullscreenBtn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <button id="fullscreenBtn">FULLSCREEN</button>
    <div id="instructions">Arrow Keys or WASD to move • Space to select • 1-4 to switch tabs</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false,
            willReadFrequently: false
        });

        // Internal game resolution - DOUBLED for sharper text
        const RENDER_SCALE = 2;
        const GAME_WIDTH = 640;
        const GAME_HEIGHT = 480;

        // Set canvas to 2x internal resolution
        canvas.width = GAME_WIDTH * RENDER_SCALE;
        canvas.height = GAME_HEIGHT * RENDER_SCALE;

        // Scale all drawing operations
        ctx.scale(RENDER_SCALE, RENDER_SCALE);

        // Disable smoothing
        ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            const scaleX = windowWidth / GAME_WIDTH;
            const scaleY = windowHeight / GAME_HEIGHT;
            const scale = Math.min(scaleX, scaleY);
            
            const finalScale = Math.max(1, Math.floor(scale));
            
            canvas.style.width = (GAME_WIDTH * finalScale) + 'px';
            canvas.style.height = (GAME_HEIGHT * finalScale) + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const fullscreenBtn = document.getElementById('fullscreenBtn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
                fullscreenBtn.textContent = 'EXIT FULLSCREEN';
            } else {
                document.exitFullscreen();
                fullscreenBtn.textContent = 'FULLSCREEN';
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenBtn.textContent = 'FULLSCREEN';
            }
        });

        const CELL_WIDTH = 23;
        const CELL_HEIGHT = 33;
        const SPRITE_OFFSET_X = 3;
        const SPRITE_OFFSET_Y = 3;
        const SPRITE_WIDTH = 20;
        const SPRITE_HEIGHT = 30;
        const DISPLAY_SCALE = 2;

        const TARGET_FPS = 30;
        const MOVE_SPEED = 4;
        const ANIMATION_SPEED = 6;

        const DIRECTION_DOWN = 0;
        const DIRECTION_RIGHT = 1;
        const DIRECTION_UP = 2;
        const DIRECTION_LEFT = 3;

        const SPRITE_ROWS = {
            [DIRECTION_DOWN]: 0,
            [DIRECTION_RIGHT]: 1,
            [DIRECTION_UP]: 2,
            [DIRECTION_LEFT]: 1
        };

        const WALK_FRAMES_4 = [0, 1, 2, 3];
        const WALK_FRAMES_2 = [0, 1, 0, 1];
        const STAND_FRAME = 0;

        const allGames = [
            { name: 'Undertale', url: 'https://choseven.github.io/Undertale', category: 'indie' },
            { name: 'Deltarune', url: 'https://choseven.github.io/Deltarune', category: 'indie' },
            { name: 'Block Blast', url: 'https://choseven.github.io/BlockBlast', category: 'classic' },
            { name: 'Hollow Knight', url: 'https://choseven.github.io/HollowKnight', category: 'indie' },
            { name: 'Last Breath Third', url: 'https://choseven.github.io/LastBreathThird', category: 'indie' },
            { name: 'Last Breath First', url: 'https://choseven.github.io/LastBreathFirst', category: 'indie' },
            { name: 'Pokemon Emerald', url: 'https://choseven.github.io/PokemonEmerald', category: 'pokemon' },
            { name: 'Pokemon Fire Red', url: 'https://choseven.github.io/PokemonFireRed', category: 'pokemon' },
            { name: 'Pokemon Heart Gold', url: 'https://choseven.github.io/PokemonHeartGold', category: 'pokemon' },
            { name: 'Pokemon Leaf Green', url: 'https://choseven.github.io/PokemonLeafGreen', category: 'pokemon' },
            { name: 'Pokemon Platinum', url: 'https://choseven.github.io/PokemonPlatinum', category: 'pokemon' },
            { name: 'Pokemon Red', url: 'https://choseven.github.io/PokemonRed', category: 'pokemon' },
            { name: 'Pokemon Ruby', url: 'https://choseven.github.io/PokemonRuby', category: 'pokemon' },
            { name: 'Pokemon Sapphire', url: 'https://choseven.github.io/PokemonSapphire', category: 'pokemon' },
            { name: 'Pokemon Soul Silver', url: 'https://choseven.github.io/PokemonSoulSilver', category: 'pokemon' },
            { name: 'Snake', url: 'https://choseven.github.io/Snake', category: 'classic' },
            { name: 'Undertale Yellow', url: 'https://choseven.github.io/UndertaleYellow', category: 'indie' },
            { name: 'Great Time Trio', url: 'https://choseven.github.io/GreatTimeTrio', category: 'indie' },
            { name: 'Cookie Clicker', url: 'https://choseven.github.io/CookieClicker', category: 'classic' },
            { name: 'Super Mario 64', url: 'https://choseven.github.io/SuperMario64', category: 'classic' },
            { name: "Baldi's Basics", url: 'https://choseven.github.io/BaldiBasics', category: 'classic' }
        ];

        let currentTab = 'all';
        let buttonTextureWidth = 0;
        let buttonTextureHeight = 0;
        let buttonTextureHoverWidth = 0;
        let buttonTextureHoverHeight = 0;
        const BUTTON_WIDTH = 180;
        const BUTTON_HEIGHT = 50;
        const BUTTON_SPACING_X = 20;
        const BUTTON_SPACING_Y = 15;
        const COLUMNS = 3;
        const BASE_FONT_SIZE = 13;
        let cameraY = 0;
        const SCROLL_SPEED = 4;

        // Save point state
        let savepointFrame = 0;
        let savepointAnimTimer = 0;
        const SAVEPOINT_ANIM_SPEED = 8;
        let showSaveDisplay = false;

        // Savepoint position - only in 'all' tab
        function getSavepointPosition() {
            if (currentTab !== 'all') return null; // Only show in 'all' tab
            
            const games = allGames; // Use all games, not filtered
            const rows = Math.ceil(games.length / COLUMNS);
            const gridStartY = 180;
            const lastRowY = gridStartY + rows * (BUTTON_HEIGHT + BUTTON_SPACING_Y) - cameraY;
            
            return {
                x: GAME_WIDTH / 2,
                y: lastRowY + 30
            };
        }

        let frisk = {
            x: GAME_WIDTH / 2,
            y: 80,
            direction: DIRECTION_DOWN,
            frame: 0,
            animTimer: 0,
            isMoving: false
        };

        let lastTime = 0;
        let accumulator = 0;
        const FRAME_TIME = 1000 / TARGET_FPS;

        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
            
            if (e.code === 'Digit1') {
                currentTab = 'all';
                cameraY = 0;
                playSound('select');
            } else if (e.code === 'Digit2') {
                currentTab = 'indie';
                cameraY = 0;
                playSound('select');
            } else if (e.code === 'Digit3') {
                currentTab = 'pokemon';
                cameraY = 0;
                playSound('select');
            } else if (e.code === 'Digit4') {
                currentTab = 'classic';
                cameraY = 0;
                playSound('select');
            }
            
            if (e.code === 'Space') {
                // Check if near save point
                if (isNearSavepoint()) {
                    playSound('confirm');
                    showSaveDisplay = !showSaveDisplay;
                    return;
                }
                
                // Check if over a game button
                const hoveredGame = getHoveredGame();
                if (hoveredGame) {
                    playSound('confirm');
                    setTimeout(() => {
                        window.location.href = hoveredGame.url;
                    }, 100);
                }
            }
            
            // Close save display with Space or Escape
            if ((e.code === 'Space' || e.code === 'Escape') && showSaveDisplay) {
                showSaveDisplay = false;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        const spritesheet = new Image();
        spritesheet.src = 'frisk.png';

        const buttonTexture = new Image();
        buttonTexture.src = 'button2.png';

        const buttonTextureHover = new Image();
        buttonTextureHover.src = 'button3.png';

        const savepointSprite = new Image();
        savepointSprite.src = 'Savepoint.png';

        const saveDisplay = new Image();
        saveDisplay.src = 'SavepointDisplay.png';

        let fontLoaded = false;
        let charaFontLoaded = false;
        let windyFontLoaded = false;

        async function loadCustomFont() {
            try {
                const font = new FontFace('DeterminationMono', 'url(DeterminationMonoWebRegular.woff2)');
                await font.load();
                document.fonts.add(font);
                console.log('DeterminationMono font loaded!');
            } catch (error) {
                console.error('DeterminationMono font load error:', error);
            }
            fontLoaded = true;
            checkStart();
        }

        async function loadCharaFont() {
            try {
                const font = new FontFace('Chara', 'url(chara.woff2)');
                await font.load();
                document.fonts.add(font);
                console.log('Chara font loaded!');
            } catch (error) {
                console.error('Chara font load error:', error);
            }
            charaFontLoaded = true;
            checkStart();
        }

        async function loadWindyFont() {
            try {
                const font = new FontFace('Windy', 'url(windy.woff2)');
                await font.load();
                document.fonts.add(font);
                console.log('Windy font loaded!');
            } catch (error) {
                console.error('Windy font load error:', error);
            }
            windyFontLoaded = true;
            checkStart();
        }

        loadCustomFont();
        loadCharaFont();
        loadWindyFont();

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            if (type === 'select') {
                osc.frequency.value = 400;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.05);
            } else if (type === 'confirm') {
                osc.frequency.value = 600;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        function getSpriteCoords(direction, frameIndex, isMoving) {
            const row = SPRITE_ROWS[direction];
            
            let col;
            if (!isMoving) {
                col = STAND_FRAME;
            } else {
                if (direction === DIRECTION_UP || direction === DIRECTION_DOWN) {
                    col = WALK_FRAMES_4[frameIndex % 4];
                } else {
                    col = WALK_FRAMES_2[frameIndex % 4];
                }
            }
            
            const sx = SPRITE_OFFSET_X + col * CELL_WIDTH;
            const sy = SPRITE_OFFSET_Y + row * CELL_HEIGHT;
            
            return { 
                sx, 
                sy, 
                flip: direction === DIRECTION_RIGHT
            };
        }

        function getCurrentGames() {
            if (currentTab === 'all') {
                return allGames;
            }
            return allGames.filter(game => game.category === currentTab);
        }

        function calculateGamePositions() {
            const games = getCurrentGames();
            const gridStartY = 180;
            const positions = [];
            
            const rows = Math.ceil(games.length / COLUMNS);
            const totalGridWidth = COLUMNS * BUTTON_WIDTH + (COLUMNS - 1) * BUTTON_SPACING_X;
            const startX = (GAME_WIDTH - totalGridWidth) / 2 + BUTTON_WIDTH / 2;
            
            games.forEach((game, index) => {
                const col = index % COLUMNS;
                const row = Math.floor(index / COLUMNS);
                
                const x = startX + col * (BUTTON_WIDTH + BUTTON_SPACING_X);
                const y = gridStartY + row * (BUTTON_HEIGHT + BUTTON_SPACING_Y) - cameraY;
                
                positions.push({
                    ...game,
                    x: x,
                    y: y,
                    width: BUTTON_WIDTH,
                    height: BUTTON_HEIGHT
                });
            });
            
            return positions;
        }

        function getMaxCameraY() {
            const games = getCurrentGames();
            const rows = Math.ceil(games.length / COLUMNS);
            const extraSpace = (currentTab === 'all') ? 80 : 0; // Extra space only in 'all' tab
            const totalHeight = rows * (BUTTON_HEIGHT + BUTTON_SPACING_Y) + extraSpace;
            const viewableHeight = GAME_HEIGHT - 200;
            return Math.max(0, totalHeight - viewableHeight);
        }

        function isNearSavepoint() {
            const savePos = getSavepointPosition();
            if (!savePos) return false;
            
            const distance = Math.sqrt(
                Math.pow(frisk.x - savePos.x, 2) + 
                Math.pow(frisk.y - savePos.y, 2)
            );
            return distance < 50; // Interaction radius
        }
        
        function checkSavepointCollision(newX, newY) {
            const savePos = getSavepointPosition();
            if (!savePos) return false;
            
            // Savepoint is 44x44 pixels (22x21 scaled 2x), centered at savePos
            const starLeft = savePos.x - 22;
            const starRight = savePos.x + 22;
            const starTop = savePos.y - 22;
            const starBottom = savePos.y + 22;
            
            // Frisk's collision point (center of body)
            const friskBodyY = newY + 15; // Offset to body center
            
            // Check if Frisk overlaps with the star
            if (newX >= starLeft && newX <= starRight && 
                friskBodyY >= starTop && friskBodyY <= starBottom) {
                return true;
            }
            
            return false;
        }

        function drawFrisk() {
            const { sx, sy, flip } = getSpriteCoords(frisk.direction, frisk.frame, frisk.isMoving);
            
            ctx.save();
            
            const drawWidth = SPRITE_WIDTH * DISPLAY_SCALE;
            const drawHeight = SPRITE_HEIGHT * DISPLAY_SCALE;
            const drawX = Math.floor(frisk.x - drawWidth / 2);
            const drawY = Math.floor(frisk.y - drawHeight / 2);
            
            if (flip) {
                ctx.translate(drawX + drawWidth, drawY);
                ctx.scale(-1, 1);
                ctx.drawImage(
                    spritesheet,
                    sx, sy, SPRITE_WIDTH, SPRITE_HEIGHT,
                    0, 0,
                    drawWidth, drawHeight
                );
            } else {
                ctx.drawImage(
                    spritesheet,
                    sx, sy, SPRITE_WIDTH, SPRITE_HEIGHT,
                    drawX, drawY,
                    drawWidth, drawHeight
                );
            }
            
            ctx.restore();
        }

        function drawSavepoint() {
            const savePos = getSavepointPosition();
            if (!savePos || !savepointSprite.complete) return;
            
            // Sprite frames are 22x21 each, side by side
            // Frame 0: Yellow star (0, 0, 22, 21)
            // Frame 1: Outline star (22, 0, 22, 21)
            const FRAME_WIDTH = 22;
            const FRAME_HEIGHT = 21;
            const sx = savepointFrame * FRAME_WIDTH; // 0 or 22
            const sy = 0;
            
            const DRAW_SIZE = 44; // Scale 2x (22 * 2)
            
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(
                savepointSprite,
                sx, sy, FRAME_WIDTH, FRAME_HEIGHT,
                Math.floor(savePos.x - DRAW_SIZE / 2), 
                Math.floor(savePos.y - DRAW_SIZE / 2),
                DRAW_SIZE, DRAW_SIZE
            );
            ctx.restore();
            
            // Show interaction hint if near
            if (isNearSavepoint() && !showSaveDisplay) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(Math.floor(savePos.x - 60), Math.floor(savePos.y + 25), 120, 25);
                ctx.fillStyle = '#fff';
                ctx.font = '12px "Windy", "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Press SPACE', Math.floor(savePos.x), Math.floor(savePos.y + 37));
            }
        }

        function drawSaveDisplay() {
            if (!showSaveDisplay || !saveDisplay.complete) return;
            
            // Center the display
            const displayWidth = saveDisplay.width;
            const displayHeight = saveDisplay.height;
            const x = (GAME_WIDTH - displayWidth) / 2;
            const y = (GAME_HEIGHT - displayHeight) / 2;
            
            ctx.save();
            ctx.drawImage(saveDisplay, x, y);
            
            // Draw text on the display - smaller font to fit
            ctx.fillStyle = '#fff';
            ctx.font = '12px "Windy", "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            const lines = [
                "I'm not quite sure what to put here,",
                "but I guess I'll mention my email:",
                "loganshadow10@gmail.com",
                "",
                "Note that this menu was created by AI",
                "(besides the small amounts of art",
                "and fonts)."
            ];
            
            const lineHeight = 18;
            const startY = y + displayHeight / 2 - (lines.length * lineHeight) / 2;
            
            lines.forEach((line, index) => {
                ctx.fillText(line, GAME_WIDTH / 2, startY + index * lineHeight);
            });
            
            ctx.restore();
        }

        function getHoveredGame() {
            const games = calculateGamePositions();
            
            const bodyOffsetY = 15;
            const hitX = frisk.x;
            const hitY = frisk.y + bodyOffsetY;
            
            for (let game of games) {
                const left = game.x - game.width / 2;
                const right = game.x + game.width / 2;
                const top = game.y - game.height / 2;
                const bottom = game.y + game.height / 2;
                
                if (hitX >= left && hitX <= right && hitY >= top && hitY <= bottom) {
                    return game;
                }
            }
            return null;
        }

        function drawButtons() {
            const games = calculateGamePositions();
            const hoveredGame = getHoveredGame();
            
            games.forEach(game => {
                if (game.y + game.height < 140 || game.y > GAME_HEIGHT - 20) {
                    return;
                }
                
                const isHovered = game === hoveredGame;
                
                ctx.save();
                
                const left = Math.floor(game.x - game.width / 2);
                const top = Math.floor(game.y - game.height / 2);
                
                const currentButtonTexture = isHovered ? buttonTextureHover : buttonTexture;
                const currentTextureWidth = isHovered ? buttonTextureHoverWidth : buttonTextureWidth;
                const currentTextureHeight = isHovered ? buttonTextureHoverHeight : buttonTextureHeight;
                
                if (currentButtonTexture.complete && currentTextureWidth > 0) {
                    const edgeSize = Math.min(16, Math.floor(currentTextureWidth / 3), Math.floor(currentTextureHeight / 3));
                    
                    ctx.drawImage(currentButtonTexture, 0, 0, edgeSize, edgeSize, 
                                  left, top, edgeSize, edgeSize);
                    ctx.drawImage(currentButtonTexture, currentTextureWidth - edgeSize, 0, edgeSize, edgeSize,
                                  left + BUTTON_WIDTH - edgeSize, top, edgeSize, edgeSize);
                    ctx.drawImage(currentButtonTexture, 0, currentTextureHeight - edgeSize, edgeSize, edgeSize,
                                  left, top + BUTTON_HEIGHT - edgeSize, edgeSize, edgeSize);
                    ctx.drawImage(currentButtonTexture, currentTextureWidth - edgeSize, currentTextureHeight - edgeSize, edgeSize, edgeSize,
                                  left + BUTTON_WIDTH - edgeSize, top + BUTTON_HEIGHT - edgeSize, edgeSize, edgeSize);
                    
                    const centerWidth = currentTextureWidth - (edgeSize * 2);
                    const centerHeight = currentTextureHeight - (edgeSize * 2);
                    
                    for (let x = edgeSize; x < BUTTON_WIDTH - edgeSize; x += centerWidth) {
                        const w = Math.min(centerWidth, BUTTON_WIDTH - edgeSize - x);
                        ctx.drawImage(currentButtonTexture, edgeSize, 0, w, edgeSize,
                                      left + x, top, w, edgeSize);
                    }
                    for (let x = edgeSize; x < BUTTON_WIDTH - edgeSize; x += centerWidth) {
                        const w = Math.min(centerWidth, BUTTON_WIDTH - edgeSize - x);
                        ctx.drawImage(currentButtonTexture, edgeSize, currentTextureHeight - edgeSize, w, edgeSize,
                                      left + x, top + BUTTON_HEIGHT - edgeSize, w, edgeSize);
                    }
                    for (let y = edgeSize; y < BUTTON_HEIGHT - edgeSize; y += centerHeight) {
                        const h = Math.min(centerHeight, BUTTON_HEIGHT - edgeSize - y);
                        ctx.drawImage(currentButtonTexture, 0, edgeSize, edgeSize, h,
                                      left, top + y, edgeSize, h);
                    }
                    for (let y = edgeSize; y < BUTTON_HEIGHT - edgeSize; y += centerHeight) {
                        const h = Math.min(centerHeight, BUTTON_HEIGHT - edgeSize - y);
                        ctx.drawImage(currentButtonTexture, currentTextureWidth - edgeSize, edgeSize, edgeSize, h,
                                      left + BUTTON_WIDTH - edgeSize, top + y, edgeSize, h);
                    }
                    
                    for (let y = edgeSize; y < BUTTON_HEIGHT - edgeSize; y += centerHeight) {
                        for (let x = edgeSize; x < BUTTON_WIDTH - edgeSize; x += centerWidth) {
                            const w = Math.min(centerWidth, BUTTON_WIDTH - edgeSize - x);
                            const h = Math.min(centerHeight, BUTTON_HEIGHT - edgeSize - y);
                            ctx.drawImage(currentButtonTexture, edgeSize, edgeSize, w, h,
                                          left + x, top + y, w, h);
                        }
                    }
                } else {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(left, top, game.width, game.height);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(left, top, game.width, game.height);
                }
                
                ctx.fillStyle = isHovered ? '#ffff00' : '#eb7a23';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${BASE_FONT_SIZE}px "Chara", "Courier New", monospace`;
                
                const maxWidth = game.width - 30;
                const words = game.name.split(' ');
                const fullTextWidth = ctx.measureText(game.name).width;
                
                if (fullTextWidth > maxWidth && words.length > 1) {
                    let line1 = '';
                    let line2 = '';
                    let currentLine = '';
                    
                    for (let i = 0; i < words.length; i++) {
                        const testLine = currentLine ? currentLine + ' ' + words[i] : words[i];
                        const testWidth = ctx.measureText(testLine).width;
                        
                        if (testWidth > maxWidth && currentLine) {
                            line1 = currentLine;
                            line2 = words.slice(i).join(' ');
                            break;
                        }
                        currentLine = testLine;
                    }
                    
                    if (!line1) {
                        line1 = currentLine;
                    }
                    
                    const lineHeight = BASE_FONT_SIZE + 2;
                    ctx.fillText(line1, game.x, game.y - lineHeight / 2);
                    if (line2) {
                        ctx.fillText(line2, game.x, game.y + lineHeight / 2);
                    }
                } else {
                    ctx.fillText(game.name, game.x, game.y);
                }
                
                ctx.restore();
            });
        }

        function update() {
            // Don't allow movement when save display is open
            if (showSaveDisplay) {
                frisk.isMoving = false;
                frisk.frame = 0;
                frisk.animTimer = 0;
                
                // Still animate savepoint even when display is open
                savepointAnimTimer++;
                if (savepointAnimTimer >= SAVEPOINT_ANIM_SPEED) {
                    savepointAnimTimer = 0;
                    savepointFrame = (savepointFrame + 1) % 2;
                }
                return;
            }
            
            let dx = 0;
            let dy = 0;
            
            if (keys['ArrowRight'] || keys['KeyD']) {
                dx = MOVE_SPEED;
                frisk.direction = DIRECTION_RIGHT;
            } else if (keys['ArrowLeft'] || keys['KeyA']) {
                dx = -MOVE_SPEED;
                frisk.direction = DIRECTION_LEFT;
            }
            
            if (keys['ArrowUp'] || keys['KeyW']) {
                dy = -MOVE_SPEED;
                frisk.direction = DIRECTION_UP;
            } else if (keys['ArrowDown'] || keys['KeyS']) {
                dy = MOVE_SPEED;
                frisk.direction = DIRECTION_DOWN;
            }
            
            // Normalize diagonal movement - CRITICAL FIX
            if (dx !== 0 && dy !== 0) {
                const normalizer = MOVE_SPEED / Math.sqrt(dx * dx + dy * dy);
                dx *= normalizer;
                dy *= normalizer;
            }
            
            frisk.isMoving = dx !== 0 || dy !== 0;
            
            let newX = frisk.x + dx;
            let newY = frisk.y + dy;
            
            // Check collision with savepoint before applying movement
            if (checkSavepointCollision(newX, newY)) {
                // Block movement but DON'T stop Frisk or savepoint animation
                // Try moving only horizontally
                if (!checkSavepointCollision(newX, frisk.y)) {
                    newY = frisk.y;
                }
                // Try moving only vertically
                else if (!checkSavepointCollision(frisk.x, newY)) {
                    newX = frisk.x;
                }
                // Can't move at all
                else {
                    newX = frisk.x;
                    newY = frisk.y;
                    frisk.isMoving = false;
                }
            }
            
            newX = Math.max(30, Math.min(GAME_WIDTH - 30, newX));
            newY = Math.max(140, Math.min(GAME_HEIGHT - 30, newY));
            
            const maxCameraY = getMaxCameraY();
            
            if (maxCameraY > 0 && dy !== 0) {
                // Scroll down when Frisk gets to bottom third of screen
                if (newY > GAME_HEIGHT - 150 && dy > 0) {
                    const scrollAmount = Math.min(Math.abs(dy), SCROLL_SPEED);
                    const desiredCameraY = cameraY + scrollAmount;
                    if (desiredCameraY <= maxCameraY) {
                        cameraY = desiredCameraY;
                        newY -= scrollAmount;
                    }
                }
                // Scroll up when Frisk gets to top third of screen
                else if (newY < 200 && dy < 0) {
                    const scrollAmount = Math.min(Math.abs(dy), SCROLL_SPEED);
                    const desiredCameraY = cameraY - scrollAmount;
                    if (desiredCameraY >= 0) {
                        cameraY = desiredCameraY;
                        newY += scrollAmount;
                    }
                }
            }
            
            newY = Math.max(140, Math.min(GAME_HEIGHT - 30, newY));
            
            frisk.x = newX;
            frisk.y = newY;
            
            if (frisk.isMoving) {
                frisk.animTimer++;
                if (frisk.animTimer >= ANIMATION_SPEED) {
                    frisk.animTimer = 0;
                    frisk.frame = (frisk.frame + 1) % 4;
                }
            } else {
                frisk.frame = 0;
                frisk.animTimer = 0;
            }
            
            // ALWAYS animate savepoint regardless of collision
            savepointAnimTimer++;
            if (savepointAnimTimer >= SAVEPOINT_ANIM_SPEED) {
                savepointAnimTimer = 0;
                savepointFrame = (savepointFrame + 1) % 2;
            }
        }

        function drawTabs() {
            const tabs = [
                { id: 'all', name: 'ALL', x: GAME_WIDTH / 2 - 150 },
                { id: 'indie', name: 'INDIE', x: GAME_WIDTH / 2 - 50 },
                { id: 'pokemon', name: 'POKEMON', x: GAME_WIDTH / 2 + 50 },
                { id: 'classic', name: 'CLASSIC', x: GAME_WIDTH / 2 + 150 }
            ];
            
            tabs.forEach(tab => {
                const isActive = currentTab === tab.id;
                
                ctx.fillStyle = isActive ? '#fff' : '#666';
                ctx.font = isActive ? 'bold 14px "Chara", "Courier New", monospace' : '14px "Chara", "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(tab.name, tab.x, 100);
                
                if (isActive) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const textWidth = ctx.measureText(tab.name).width;
                    ctx.moveTo(tab.x - textWidth / 2, 108);
                    ctx.lineTo(tab.x + textWidth / 2, 108);
                    ctx.stroke();
                }
            });
            
            ctx.fillStyle = '#888';
            ctx.font = '10px "Chara", "Courier New", monospace';
            ctx.textBaseline = 'middle';
            ctx.fillText('Press 1-4 to switch tabs', GAME_WIDTH / 2, 120);
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 42px "DeterminationMono", "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('GAME SELECT', GAME_WIDTH / 2, 50);
            
            drawTabs();
            
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 140, GAME_WIDTH, GAME_HEIGHT - 140);
            ctx.clip();
            
            drawButtons();
            
            // Draw savepoint in the scrollable area
            drawSavepoint();
            
            ctx.restore();
            
            drawFrisk();
            
            const hoveredGame = getHoveredGame();
            if (hoveredGame && !showSaveDisplay) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(GAME_WIDTH / 2 - 100, GAME_HEIGHT - 50, 200, 30);
                ctx.fillStyle = '#ff0';
                ctx.font = '14px "Chara", "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Press SPACE to play!', GAME_WIDTH / 2, GAME_HEIGHT - 32);
            }
            
            // Draw save display on top of everything
            drawSaveDisplay();
        }

        function gameLoop(currentTime) {
            if (lastTime === 0) {
                lastTime = currentTime;
            }
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            accumulator += deltaTime;
            
            while (accumulator >= FRAME_TIME) {
                update();
                accumulator -= FRAME_TIME;
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        let spritesheetLoaded = false;
        let buttonTextureLoaded = false;
        let buttonTextureHoverLoaded = false;
        let savepointLoaded = false;
        let saveDisplayLoaded = false;

        function checkStart() {
            if (spritesheetLoaded && buttonTextureLoaded && buttonTextureHoverLoaded && 
                fontLoaded && charaFontLoaded && windyFontLoaded && savepointLoaded && saveDisplayLoaded) {
                console.log('All assets loaded!');
                requestAnimationFrame(gameLoop);
            }
        }

        spritesheet.onload = () => {
            console.log('Spritesheet loaded!');
            spritesheetLoaded = true;
            checkStart();
        };

        buttonTexture.onload = () => {
            console.log('Button texture loaded!');
            buttonTextureWidth = buttonTexture.width;
            buttonTextureHeight = buttonTexture.height;
            buttonTextureLoaded = true;
            checkStart();
        };

        buttonTextureHover.onload = () => {
            console.log('Button hover texture loaded!');
            buttonTextureHoverWidth = buttonTextureHover.width;
            buttonTextureHoverHeight = buttonTextureHover.height;
            buttonTextureHoverLoaded = true;
            checkStart();
        };

        savepointSprite.onload = () => {
            console.log('Savepoint sprite loaded!');
            savepointLoaded = true;
            checkStart();
        };

        saveDisplay.onload = () => {
            console.log('Save display loaded!');
            saveDisplayLoaded = true;
            checkStart();
        };

        spritesheet.onerror = () => {
            console.error('Failed to load spritesheet');
            spritesheetLoaded = true;
            checkStart();
        };

        buttonTexture.onerror = () => {
            console.error('Failed to load button texture');
            buttonTextureLoaded = true;
            checkStart();
        };

        buttonTextureHover.onerror = () => {
            console.error('Failed to load button hover texture');
            buttonTextureHoverLoaded = true;
            checkStart();
        };

        savepointSprite.onerror = () => {
            console.error('Failed to load savepoint sprite');
            savepointLoaded = true;
            checkStart();
        };

        saveDisplay.onerror = () => {
            console.error('Failed to load save display');
            saveDisplayLoaded = true;
            checkStart();
        };

        document.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        });
        document.addEventListener('keydown', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }, { once: true });
    </script>
</body>
</html>