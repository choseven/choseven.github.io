<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>GXC Game</title>
    <style>
      @-webkit-keyframes rotation {
        from { -webkit-transform: rotate(0deg); }
        to { -webkit-transform: rotate(360deg); }
      }
      @-moz-keyframes rotation {
        from { -moz-transform: rotate(0deg); }
        to { -moz-transform: rotate(360deg); }
      }
      @-o-keyframes rotation {
        from { -o-transform: rotate(0deg); }
        to { -o-transform: rotate(360deg); }
      }
      @keyframes rotation {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }

      body {
        font-family: arial;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        min-width: 100vw;
        background: radial-gradient(56.63% 56.63% at 50% 43.37%, #1c1726 0%, #060612 100%);
      }
      .emscripten {
        padding-right: 0;
        margin-left: auto;
        margin-right: auto;
        display: block;
      }
      div.emscripten { text-align: center; }
      canvas.emscripten {
        display: none;
        border: 0px none;
        background-color: black;
        position: relative;
        transition: opacity 5s ease-in;
        -webkit-transition: opacity 5s ease-in;
        opacity: 0;
        image-rendering: optimizeSpeed;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: -o-crisp-edges;
        image-rendering: pixelated;
        -ms-interpolation-mode: nearest-neighbor;
      }
      canvas.active {
        animation-name: fadeIn;
        animation-duration: 2s;
        opacity: 1;
      }
      @keyframes fadeIn {
        0% { opacity: 0; }
        100% { opacity: 1; }
      }
      .spinner {
        height: 30px;
        width: 30px;
        -webkit-animation: rotation 0.8s linear infinite;
        -moz-animation: rotation 0.8s linear infinite;
        -o-animation: rotation 0.8s linear infinite;
        animation: rotation 0.8s linear infinite;
        border: 5px solid #bdff00;
        border-top: 5px solid #719900;
        border-radius: 100%;
      }
      #status {
        display: inline-block;
        vertical-align: top;
        font-weight: bold;
        color: white;
      }
      #progress {
        width: 250px;
        height: 10px;
        -webkit-appearance: none;
        appearance: none;
        padding: 5px;
      }
      progress[value]::-webkit-progress-bar {
        background-color: #8492a6;
        height: 10px;
        border-radius: 15px;
      }
      progress[value]::-webkit-progress-value {
        background-image: -webkit-linear-gradient(left, #719900, #bdff00);
        height: 10px;
        border-radius: 15px;
      }
      div.loading {
        position: absolute;
        top: 0; bottom: 0; left: 0; right: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        pointer-events: none;
      }
      div.loading > * {
        padding: 10px;
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
    <div class="loading">
      <div class="spinner" id="spinner"></div>
      <div class="emscripten" id="status">Downloading...</div>
      <progress value="0" max="100" id="progress" hidden="1"></progress>
    </div>

    <script async data-ad-client="ca-pub-123" data-ad-frequency-hint="30s" data-adbreak-test="on"
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      window.adsbygoogle = window.adsbygoogle || [];
      const adBreak = adConfig = function(o) {adsbygoogle.push(o);}
    </script>

    <script type="text/javascript">
      const CHANGE_ASPECT_RATIO = true;
      
      const GAME_UNX_CDN_URL = "https://files.catbox.moe/y8y4x9.unx";

      var statusElement = document.getElementById("status");
      var progressElement = document.getElementById("progress");
      var spinnerElement = document.getElementById("spinner");
      var canvasElement = document.getElementById("canvas");
      var startingHeight, startingWidth, startingAspect;

      // Intercept game.unx requests and redirect to CDN
      const originalFetch = window.fetch;
      window.fetch = async function (...args) {
        let [url, options] = args;
        if (typeof url === 'string' && url.includes("game.unx")) {
          console.log("Redirecting game.unx to CDN:", GAME_UNX_CDN_URL);
          url = GAME_UNX_CDN_URL;
        } else if (url instanceof Request && url.url.includes("game.unx")) {
          console.log("Redirecting Request game.unx to CDN");
          url = new Request(GAME_UNX_CDN_URL, url);
        }
        return originalFetch.call(this, url, options);
      };

      const originalOpen = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function (method, url, ...rest) {
        if (url.includes("game.unx")) {
          console.log("Redirecting XHR game.unx to CDN");
          url = GAME_UNX_CDN_URL;
        }
        return originalOpen.call(this, method, url, ...rest);
      };

      var Module = {
        preRun: [],
        postRun: [],
        print: (function () {
          var element = document.getElementById("output");
          if (element) element.value = "";
          return function (text) {
            if (arguments.length > 1)
              text = Array.prototype.slice.call(arguments).join(" ");
            console.log(text);
            if (text === "Entering main loop.") {
              ensureAspectRatio();
            }
            if (element) {
              element.value += text + "\n";
              element.scrollTop = element.scrollHeight;
            }
          };
        })(),
        printErr: function (text) {
          if (arguments.length > 1)
            text = Array.prototype.slice.call(arguments).join(" ");
          console.error(text);
        },
        canvas: (function () {
          var canvas = document.getElementById("canvas");
          canvas.addEventListener("webglcontextlost", function (e) {
            alert("WebGL context lost. You will need to reload the page.");
            e.preventDefault();
          }, false);
          return canvas;
        })(),
        setStatus: function (text) {
          if (!Module.setStatus.last)
            Module.setStatus.last = { time: Date.now(), text: "" };
          if (text === Module.setStatus.last.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return;
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2]) * 100;
            progressElement.max = parseInt(m[4]) * 100;
            progressElement.hidden = false;
            spinnerElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
            if (!text) {
              spinnerElement.style.display = "none";
              canvasElement.style.display = "block";
            }
          }
          statusElement.innerHTML = text;
        },
        totalDependencies: 0,
        monitorRunDependencies: function (left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? "Preparing... (" + (this.totalDependencies - left) + "/" + this.totalDependencies + ")" : "All downloads complete.");
        },
      };
      Module.setStatus("Downloading...");
      window.onerror = function (event) {
        Module.setStatus("Exception thrown, see JavaScript console");
        spinnerElement.style.display = "none";
        Module.setStatus = function (text) {
          if (text) Module.printErr("[post-exception status] " + text);
        };
      };

      if (typeof window === "object") {
        Module['arguments'] = window.location.search.substr(1).trim().split('&');
        if (!Module['arguments'][0]) Module['arguments'] = [];
      }

      var g_pAddAsyncMethod = -1;
      function setAddAsyncMethod(asyncMethod) { g_pAddAsyncMethod = asyncMethod; }
      var g_pJSExceptionHandler = undefined;
      function setJSExceptionHandler(exceptionHandler) {
        if (typeof exceptionHandler == "function") g_pJSExceptionHandler = exceptionHandler;
      }
      function hasJSExceptionHandler() {
        return (g_pJSExceptionHandler != undefined) && (typeof g_pJSExceptionHandler == "function");
      }
      function doJSExceptionHandler(exceptionJSON) {
        if (typeof g_pJSExceptionHandler == "function") {
          var exception = JSON.parse(exceptionJSON);
          g_pJSExceptionHandler(exception);
        }
      }
      function manifestFiles() {
        return ["runner.data","runner.js","runner.wasm","audio-worklet.js","game.unx"].join(";");
      }
      function onFirstFrameRendered() {}
      function onGameSetWindowSize(width,height) {}
      function triggerAd(adId, _callback_beforeAd, _callback_afterAd, _callback_adDismissed, _callback_adViewed, _callback_adbreakDone) {
        var pRValueCopy = triggerAdPrefix(_callback_beforeAd, _callback_afterAd, _callback_adDismissed, _callback_adViewed, _callback_adbreakDone);
        var pCallbackBeforeAd = pRValueCopy + (0*16);
        var pCallbackAfterAd = pRValueCopy + (1*16);
        var pCallbackAdDismissed = pRValueCopy + (2*16);
        var pCallbackAdViewed = pRValueCopy + (3*16);
        var pCallbackAdBreakDone = pRValueCopy + (4*16);
        adBreak({
          "type": "reward", "name": adId,
          "beforeAd": () => { console.log("beforeAd"); doGMLCallback(pCallbackBeforeAd, {id:adId}); },
          "afterAd": () => { console.log("afterAd"); doGMLCallback(pCallbackAfterAd, {id:adId}); },
          "beforeReward": (showAdFn) => { console.log("beforeReward"); showAdFn(); },
          "adDismissed": () => { console.log("adDismissed"); doGMLCallback(pCallbackAdDismissed, {id:adId}); },
          "adViewed": () => { console.log("adViewed"); doGMLCallback(pCallbackAdViewed, {id:adId}); },
          "adBreakDone": (placementInfo) => { console.log("adBreakDone"); doGMLCallback(pCallbackAdBreakDone, {id:adId}); triggerAdPostfix(pRValueCopy); },
        });
      }
      function triggerPayment(itemId, _callback_PaymentComplete) {
        var pRValueCopy = triggerPaymentPrefix(_callback_PaymentComplete);
        setTimeout(() => { console.log("triggerPayment"); doGMLCallback(pRValueCopy, {id:itemId}); }, 1000);
        triggerPaymentPostfix();
      }
      function ensureAspectRatio() {
        if(canvasElement===undefined) return;
        canvasElement.className = canvasElement.className.includes("active") ? canvasElement.className : canvasElement.className + " active";
        if (!CHANGE_ASPECT_RATIO) return;
        if (canvasElement.height === 150 && canvasElement.width === 300) return;
        if (startingHeight === undefined && startingWidth === undefined) {
          startingHeight = canvasElement.height;
          startingWidth = canvasElement.width;
          startingAspect = startingWidth / startingHeight;
        }
        const maxWidth = window.innerWidth;
        const maxHeight = window.innerHeight;
        var newHeight, newWidth;
        var heightQuotient = startingHeight / maxHeight;
        var widthQuotient = startingWidth / maxWidth;
        if (heightQuotient > widthQuotient) {
          newHeight = maxHeight;
          newWidth = newHeight * startingAspect;
        } else {
          newWidth = maxWidth;
          newHeight = newWidth / startingAspect;
        }
        canvasElement.style.height = newHeight + "px";
        canvasElement.style.width = newWidth + "px";
      }
      const resizeObserver = new ResizeObserver(() => window.requestAnimationFrame(ensureAspectRatio));
      resizeObserver.observe(document.body);
    </script>
    <script async type="text/javascript" src="runner.js"></script>
  </body>
</html>